name: Deepstream Jetson Docker

on:
  push:
    tags:
      - 'v?[0-9]+.[0-9]+.[0-9]+*'
  pull_request:

jobs:

  build-test-report-publish:
    runs-on: [self-hosted, xavier]
    strategy:
      matrix:
       include:
         - target: dev
           arch: arm64

    steps:

      - name: Define docker image name
        run: |
          echo "IMAGE_NAME=ghcr.io/${{ github.repository }}-${{ matrix.arch }}-${{ matrix.target }}" >> $GITHUB_ENV

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v1 
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.CR_PAT }}

      - name: Checkout
        uses: actions/checkout@v2

      - name: Define docker metadata variables
        id: docker_meta
        uses: crazy-max/ghaction-docker-meta@v1
        with:
          images: ${{ env.IMAGE_NAME }}
          tag-sha: true # add git short SHA as Docker tag
          tag-semver: |
            {{version}}
            {{major}}
            {{major}}.{{minor}}
            {{major}}.{{minor}}.{{patch}}

      - name: Poetry export requirements
        id: poetry-export-reqs
        run: |
          ./.scripts/export-reqs.sh
          ./.scripts/export-dev-reqs.sh

      - name: Build docker development image
        id: build-docker-dev
        run: |
          ./.scripts/docker-build.py \
            "${{ steps.docker_meta.outputs.labels }}" \
            "${{ steps.docker_meta.outputs.tags }}" \
            docker/${{ matrix.arch }}.Dockerfile \
            . \
            ${{ matrix.target }}

      - name: Define current Docker image and container names
        run: |
          export CURRENT_IMAGE=${{ env.IMAGE_NAME }}:${{ steps.docker_meta.outputs.version }} \
          && echo "CURRENT_IMAGE=$CURRENT_IMAGE" >> $GITHUB_ENV

      - name: Run Container detached
        run: |
          xhost +local:root \
          && docker run \
            --rm \
            --detach \
            --net=host \
            --runtime=nvidia \
            --cidfile=./current-container \
            -e DISPLAY=:0 \
            -e DBUS_FATAL_WARNINGS=0 \
            -v /tmp/.X11-unix:/tmp/.X11-unix \
            -v `pwd`/.git:/opt/pysetup/.git \
            --entrypoint tail \
            ${{ env.CURRENT_IMAGE }} \
            -f /dev/null \
          && export CONTAINER_NAME=`cat ./current-container` \
          && echo "CONTAINER_NAME=$CONTAINER_NAME" >> $GITHUB_ENV
        env:
          DISPLAY: :0

      - name: Create Poetry Artifact - poetry build sdist and wheels
        run: |
          docker exec ${{ env.CONTAINER_NAME }} \
            poetry build --format wheel
          docker cp ${{ env.CONTAINER_NAME }}:/opt/pysetup/dist dist
          export WHEEL=`ls dist | grep whl | tail -n1` \
            && echo "WHEEL=$WHEEL" >> $GITHUB_ENV

      - name: Run Code Style - Format
        id: format
        run: |
          docker exec ${{ env.CONTAINER_NAME }} pre-commit clean
          docker exec ${{ env.CONTAINER_NAME }} pre-commit run --all-files docformatter
          docker exec ${{ env.CONTAINER_NAME }} pre-commit run --all-files black
          docker exec ${{ env.CONTAINER_NAME }} pre-commit run --all-files isort

      - name: Run Code Style - Lint
        id: lint
        run: |
          docker exec ${{ env.CONTAINER_NAME }} pre-commit run --all-files flakehell || echo "Lint failed!" >&2

      - name: Build Documentation
        id: docs
        run: |
          docker exec ${{ env.CONTAINER_NAME }} pre-commit run --all-files docs-build

      - name: Run Tests
        id: pytest
        run: |
          docker exec ${{ env.CONTAINER_NAME }} pre-commit run --all-files pytest

      - name: Export Documentation and testing artifacts
        id: docs-export
        run: |
          mkdir -p docs
          rm -rf docs
          docker cp ${{ env.CONTAINER_NAME }}:/opt/pysetup/docs docs
          docker cp ${{ env.CONTAINER_NAME }}:/opt/pysetup/reports reports

      - name: Export Test results
        id: badges-references
        run: |
          echo "::set-output name=version::`docker exec ${{ env.CONTAINER_NAME }} poetry version --short`"
          echo "::set-output name=docs::dev.rmclabs.io/pythiags"
          echo "::set-output name=pytest::`python3 .scripts/pytest_parser.py pytest reports/pytest.xml`"
          echo "::set-output name=coverage::`python3 .scripts/pytest_parser.py coverage reports/coverage.xml`"

      - name: Deploy Staging Docs
        uses: JamesIves/github-pages-deploy-action@4.0.0
        with:
          branch: staging.docs
          folder: docs/build

      - name: Upload pytest test results
        if: ${{ always() }}
        uses: actions/upload-artifact@v2
        with:
          name: pytest-results
          path: ./reports/pytest.xml

      - name: Upload coverage test results
        if: ${{ always() }}
        uses: actions/upload-artifact@v2
        with:
          name: coverage-results
          path: ./reports/coverage.xml

 
      - name: Publish pytest Results
        uses: EnricoMi/publish-unit-test-result-action@v1.7
        if: always()
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          files: ./reports/pytest.xml

      - name: Comment coverage Results
        uses: 5monkeys/cobertura-action@master
        with:
          path: reports/coverage.xml
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          minimum_coverage: 0

      - name: Ensure git tag and poetry version are aligned
        if: ${{ startsWith(github.ref, 'refs/tags') }}
        run: |
          export V1=`docker exec ${{ env.CONTAINER_NAME }} poetry version --short` \
          && export V2=${{ github.ref }} \
          && python3 -c "import os;e=os.environ;ref=e['V2'].lstrip('refs/tags/');assert e['V1'] == ref;open('ref','w').write(ref)" \
          cat ref

      - name: Create Version Badge
        if: ${{ startsWith(github.ref, 'refs/tags') }}
        uses: schneegans/dynamic-badges-action@v1.0.0
        with:
          auth: ${{ secrets.CR_PAT }}
          gistID: 2d30824c98461a3e43e3aa2c9802ca96
          filename: version.json
          label: version
          message: ${{ steps.badges-references.outputs.version }}
          color: yellow

      - name: Create Docs Badge
        if: ${{ startsWith(github.ref, 'refs/tags') }}
        uses: schneegans/dynamic-badges-action@v1.0.0
        with:
          auth: ${{ secrets.CR_PAT }}
          gistID: 2d30824c98461a3e43e3aa2c9802ca96
          filename: docs.json
          label: docs
          message: ${{ steps.badges-references.outputs.docs }}
          color: green

      - name: Create Pytest Badge
        if: ${{ startsWith(github.ref, 'refs/tags') }}
        uses: schneegans/dynamic-badges-action@v1.0.0
        with:
          auth: ${{ secrets.CR_PAT }}
          gistID: 2d30824c98461a3e43e3aa2c9802ca96
          filename: pytest.json
          label: pytest
          message: ${{ steps.badges-references.outputs.pytest }}
          color: green

      - name: Create Coverage Badge
        if: ${{ startsWith(github.ref, 'refs/tags') }}
        uses: schneegans/dynamic-badges-action@v1.0.0
        with:
          auth: ${{ secrets.CR_PAT }}
          gistID: 2d30824c98461a3e43e3aa2c9802ca96
          filename: coverage.json
          label: coverage
          message: ${{ steps.badges-references.outputs.coverage }}
          color: orange

      - name: Define production image name
        if: ${{ startsWith(github.ref, 'refs/tags') }}
        run: |
          echo "PROD_IMAGE_NAME=ghcr.io/${{ github.repository }}-${{ matrix.arch }}" >> $GITHUB_ENV

      - name: Docker meta
        if: ${{ startsWith(github.ref, 'refs/tags') }}
        id: docker_meta_prod
        uses: crazy-max/ghaction-docker-meta@v1
        with:
          images: ${{ env.PROD_IMAGE_NAME }}
          tag-sha: true # add git short SHA as Docker tag
          tag-semver: |
            {{version}}
            {{major}}
            {{major}}.{{minor}}
            {{major}}.{{minor}}.{{patch}}

      - name: Define production Docker image name
        run: |
          export CURRENT_IMAGE_PROD=${{ env.PROD_IMAGE_NAME }}:${{ steps.docker_meta_prod.outputs.version }} \
          && echo "CURRENT_IMAGE_PROD=$CURRENT_IMAGE_PROD" >> $GITHUB_ENV

      - name: Define production Docker image name
        run: |
          ./.scripts/export-reqs.sh
          ./.scripts/export-dev-reqs.sh

      - name: Build docker prod
        if: ${{ startsWith(github.ref, 'refs/tags') }}
        id: build-docker-prod
        run: |
          ./.scripts/docker-build.py \
            "${{ steps.docker_meta_prod.outputs.labels }}" \
            "${{ steps.docker_meta_prod.outputs.tags }}" \
            docker/${{ matrix.arch }}.Dockerfile \
            .

      - name: Deploy Production Docs
        if: ${{ startsWith(github.ref, 'refs/tags') }}
        uses: JamesIves/github-pages-deploy-action@4.0.0
        with:
          branch: docs
          folder: docs/build

      - name: Push tagged Docker image to GitHub Packages
        if: ${{ startsWith(github.ref, 'refs/tags') }}
        run: |
          docker push ${{ env.CURRENT_IMAGE_PROD }}
          docker push ${{ env.CURRENT_IMAGE }}

      - name: Create Release
        if: ${{ startsWith(github.ref, 'refs/tags') }}
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          draft: false
          prerelease: false

      - name: Upload Release Asset
        if: ${{ startsWith(github.ref, 'refs/tags') }}
        id: upload-release-asset 
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }} # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps 
          asset_path: dist/${{ env.WHEEL }}
          asset_name: ${{ env.WHEEL }}
          asset_content_type: application/zip

      - name: Stop docker container
        if: always()
        id: stop-docker-container
        run: |
          docker container rm --force ${{ env.CONTAINER_NAME }}
